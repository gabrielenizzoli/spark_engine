package dataengine.pipeline.transformation;

import dataengine.pipeline.Data2Transformation;
import dataengine.pipeline.DataSource;
import dataengine.pipeline.DataTransformation;
import lombok.Builder;
import lombok.Value;
import org.apache.spark.sql.Dataset;
import org.apache.spark.sql.Encoder;

import javax.annotation.Nonnull;

public class Merge {

    public static <S1, S2, D> DataSource<D> mergeAll(
            DataSource<S1> source1,
            DataSource<S2> source2,
            Data2Transformation<S1, S2, D> merger) {
        return source1.mergeWith(source2, merger);
    }

    // start of code generated by a utility

    /**
     * Data transformation interface that performs a custom-defined operation on 3 input Datasets
     *
     * @param <S1> type of the input dataset #1
     * @param <S2> type of the input dataset #2
     * @param <S3> type of the input dataset #3
     * @param <D>  type of the output dataset
     */
    public interface Data3Transformation<S1, S2, S3, D> {

        /**
         * Applies the transformation.
         *
         * @param s1Dataset input dataset #1
         * @param s2Dataset input dataset #2
         * @param s3Dataset input dataset #3
         * @return output dataset
         */
        Dataset<D> apply(
                Dataset<S1> s1Dataset,
                Dataset<S2> s2Dataset,
                Dataset<S3> s3Dataset
        );

        /**
         * This utility method allows to chain a transformation on the output dataset. The transformation may maintain or change the output type.
         *
         * @param tx   transformation to apply on the output
         * @param <D2> type of the output after this transformation is applied
         * @return output dataset after the transformation
         */
        default <D2> Data3Transformation<S1, S2, S3, D2> andThen(DataTransformation<D, D2> tx) {
            return (s1, s2, s3) -> tx.apply(apply(s1, s2, s3));
        }

        /**
         * This utility method applies an encoder to the output dataset.
         *
         * @param encoder encoder to apply
         * @param <D2>    type of the output after this encoding is applied
         * @return output dataset after the encoding
         */
        default <D2> Data3Transformation<S1, S2, S3, D2> andThenEncode(Encoder<D2> encoder) {
            return andThen(Transformations.encode(encoder));
        }

    }

    /**
     * DataSource that stores information needed to perform a custom-defined operation on 3 input DataSources
     *
     * @param <S1> type of the input DataSource #1
     * @param <S2> type of the input DataSource #2
     * @param <S3> type of the input DataSource #3
     * @param <D>  type of the output DataSource
     */
    @Value
    @Builder
    public static class DataSource3<S1, S2, S3, D> implements DataSource<D> {

        @Nonnull
        DataSource<S1> parentDataSource1;
        @Nonnull
        DataSource<S2> parentDataSource2;
        @Nonnull
        DataSource<S3> parentDataSource3;
        @Nonnull
        Data3Transformation<S1, S2, S3, D> transformation;

        @Override
        public Dataset<D> get() {
            return transformation.apply(
                    parentDataSource1.get(),
                    parentDataSource2.get(),
                    parentDataSource3.get()
            );
        }
    }

    /**
     * Creates a DataSource that performs an on-demand merge transformation between all the input DataSources.
     *
     * @param source1  input DataSource #1
     * @param source2  input DataSource #2
     * @param source3  input DataSource #3
     * @param merger transformation to apply
     * @param <S1>   type of the input DataSource #1
     * @param <S2>   type of the input DataSource #2
     * @param <S3>   type of the input DataSource #3
     * @param <D>    type of the output DataSource
     * @return outcome of the merge operation
     */
    public static <S1, S2, S3, D> DataSource<D> mergeAll(
            DataSource<S1> source1,
            DataSource<S2> source2,
            DataSource<S3> source3,
            Data3Transformation<S1, S2, S3, D> merger) {
        return DataSource3.<S1, S2, S3, D>builder()
                .parentDataSource1(source1)
                .parentDataSource2(source2)
                .parentDataSource3(source3)
                .transformation(merger)
                .build();
    }

    /**
     * Data transformation interface that performs a custom-defined operation on 3 input Datasets
     *
     * @param <S1> type of the input dataset #1
     * @param <S2> type of the input dataset #2
     * @param <S3> type of the input dataset #3
     * @param <S4> type of the input dataset #4
     * @param <D>  type of the output dataset
     */
    public interface Data4Transformation<S1, S2, S3, S4, D> {

        /**
         * Applies the transformation.
         *
         * @param s1Dataset input dataset #1
         * @param s2Dataset input dataset #2
         * @param s3Dataset input dataset #3
         * @param s4Dataset input dataset #4
         * @return output dataset
         */
        Dataset<D> apply(
                Dataset<S1> s1Dataset,
                Dataset<S2> s2Dataset,
                Dataset<S3> s3Dataset,
                Dataset<S4> s4Dataset
        );

        /**
         * This utility method allows to chain a transformation on the output dataset. The transformation may maintain or change the output type.
         *
         * @param tx   transformation to apply on the output
         * @param <D2> type of the output after this transformation is applied
         * @return output dataset after the transformation
         */
        default <D2> Data4Transformation<S1, S2, S3, S4, D2> andThen(DataTransformation<D, D2> tx) {
            return (s1, s2, s3, s4) -> tx.apply(apply(s1, s2, s3, s4));
        }

        /**
         * This utility method applies an encoder to the output dataset.
         *
         * @param encoder encoder to apply
         * @param <D2>    type of the output after this encoding is applied
         * @return output dataset after the encoding
         */
        default <D2> Data4Transformation<S1, S2, S3, S4, D2> andThenEncode(Encoder<D2> encoder) {
            return andThen(Transformations.encode(encoder));
        }

    }

    /**
     * DataSource that stores information needed to perform a custom-defined operation on 4 input DataSources
     *
     * @param <S1> type of the input DataSource #1
     * @param <S2> type of the input DataSource #2
     * @param <S3> type of the input DataSource #3
     * @param <S4> type of the input DataSource #4
     * @param <D>  type of the output DataSource
     */
    @Value
    @Builder
    public static class DataSource4<S1, S2, S3, S4, D> implements DataSource<D> {

        @Nonnull
        DataSource<S1> parentDataSource1;
        @Nonnull
        DataSource<S2> parentDataSource2;
        @Nonnull
        DataSource<S3> parentDataSource3;
        @Nonnull
        DataSource<S4> parentDataSource4;
        @Nonnull
        Data4Transformation<S1, S2, S3, S4, D> transformation;

        @Override
        public Dataset<D> get() {
            return transformation.apply(
                    parentDataSource1.get(),
                    parentDataSource2.get(),
                    parentDataSource3.get(),
                    parentDataSource4.get()
            );
        }
    }

    /**
     * Creates a DataSource that performs an on-demand merge transformation between all the input DataSources.
     *
     * @param source1  input DataSource #1
     * @param source2  input DataSource #2
     * @param source3  input DataSource #3
     * @param source4  input DataSource #4
     * @param merger transformation to apply
     * @param <S1>   type of the input DataSource #1
     * @param <S2>   type of the input DataSource #2
     * @param <S3>   type of the input DataSource #3
     * @param <S4>   type of the input DataSource #4
     * @param <D>    type of the output DataSource
     * @return outcome of the merge operation
     */
    public static <S1, S2, S3, S4, D> DataSource<D> mergeAll(
            DataSource<S1> source1,
            DataSource<S2> source2,
            DataSource<S3> source3,
            DataSource<S4> source4,
            Data4Transformation<S1, S2, S3, S4, D> merger) {
        return DataSource4.<S1, S2, S3, S4, D>builder()
                .parentDataSource1(source1)
                .parentDataSource2(source2)
                .parentDataSource3(source3)
                .parentDataSource4(source4)
                .transformation(merger)
                .build();
    }

    /**
     * Data transformation interface that performs a custom-defined operation on 3 input Datasets
     *
     * @param <S1> type of the input dataset #1
     * @param <S2> type of the input dataset #2
     * @param <S3> type of the input dataset #3
     * @param <S4> type of the input dataset #4
     * @param <S5> type of the input dataset #5
     * @param <D>  type of the output dataset
     */
    public interface Data5Transformation<S1, S2, S3, S4, S5, D> {

        /**
         * Applies the transformation.
         *
         * @param s1Dataset input dataset #1
         * @param s2Dataset input dataset #2
         * @param s3Dataset input dataset #3
         * @param s4Dataset input dataset #4
         * @param s5Dataset input dataset #5
         * @return output dataset
         */
        Dataset<D> apply(
                Dataset<S1> s1Dataset,
                Dataset<S2> s2Dataset,
                Dataset<S3> s3Dataset,
                Dataset<S4> s4Dataset,
                Dataset<S5> s5Dataset
        );

        /**
         * This utility method allows to chain a transformation on the output dataset. The transformation may maintain or change the output type.
         *
         * @param tx   transformation to apply on the output
         * @param <D2> type of the output after this transformation is applied
         * @return output dataset after the transformation
         */
        default <D2> Data5Transformation<S1, S2, S3, S4, S5, D2> andThen(DataTransformation<D, D2> tx) {
            return (s1, s2, s3, s4, s5) -> tx.apply(apply(s1, s2, s3, s4, s5));
        }

        /**
         * This utility method applies an encoder to the output dataset.
         *
         * @param encoder encoder to apply
         * @param <D2>    type of the output after this encoding is applied
         * @return output dataset after the encoding
         */
        default <D2> Data5Transformation<S1, S2, S3, S4, S5, D2> andThenEncode(Encoder<D2> encoder) {
            return andThen(Transformations.encode(encoder));
        }

    }

    /**
     * DataSource that stores information needed to perform a custom-defined operation on 5 input DataSources
     *
     * @param <S1> type of the input DataSource #1
     * @param <S2> type of the input DataSource #2
     * @param <S3> type of the input DataSource #3
     * @param <S4> type of the input DataSource #4
     * @param <S5> type of the input DataSource #5
     * @param <D>  type of the output DataSource
     */
    @Value
    @Builder
    public static class DataSource5<S1, S2, S3, S4, S5, D> implements DataSource<D> {

        @Nonnull
        DataSource<S1> parentDataSource1;
        @Nonnull
        DataSource<S2> parentDataSource2;
        @Nonnull
        DataSource<S3> parentDataSource3;
        @Nonnull
        DataSource<S4> parentDataSource4;
        @Nonnull
        DataSource<S5> parentDataSource5;
        @Nonnull
        Data5Transformation<S1, S2, S3, S4, S5, D> transformation;

        @Override
        public Dataset<D> get() {
            return transformation.apply(
                    parentDataSource1.get(),
                    parentDataSource2.get(),
                    parentDataSource3.get(),
                    parentDataSource4.get(),
                    parentDataSource5.get()
            );
        }
    }

    /**
     * Creates a DataSource that performs an on-demand merge transformation between all the input DataSources.
     *
     * @param source1  input DataSource #1
     * @param source2  input DataSource #2
     * @param source3  input DataSource #3
     * @param source4  input DataSource #4
     * @param source5  input DataSource #5
     * @param merger transformation to apply
     * @param <S1>   type of the input DataSource #1
     * @param <S2>   type of the input DataSource #2
     * @param <S3>   type of the input DataSource #3
     * @param <S4>   type of the input DataSource #4
     * @param <S5>   type of the input DataSource #5
     * @param <D>    type of the output DataSource
     * @return outcome of the merge operation
     */
    public static <S1, S2, S3, S4, S5, D> DataSource<D> mergeAll(
            DataSource<S1> source1,
            DataSource<S2> source2,
            DataSource<S3> source3,
            DataSource<S4> source4,
            DataSource<S5> source5,
            Data5Transformation<S1, S2, S3, S4, S5, D> merger) {
        return DataSource5.<S1, S2, S3, S4, S5, D>builder()
                .parentDataSource1(source1)
                .parentDataSource2(source2)
                .parentDataSource3(source3)
                .parentDataSource4(source4)
                .parentDataSource5(source5)
                .transformation(merger)
                .build();
    }

    /**
     * Data transformation interface that performs a custom-defined operation on 3 input Datasets
     *
     * @param <S1> type of the input dataset #1
     * @param <S2> type of the input dataset #2
     * @param <S3> type of the input dataset #3
     * @param <S4> type of the input dataset #4
     * @param <S5> type of the input dataset #5
     * @param <S6> type of the input dataset #6
     * @param <D>  type of the output dataset
     */
    public interface Data6Transformation<S1, S2, S3, S4, S5, S6, D> {

        /**
         * Applies the transformation.
         *
         * @param s1Dataset input dataset #1
         * @param s2Dataset input dataset #2
         * @param s3Dataset input dataset #3
         * @param s4Dataset input dataset #4
         * @param s5Dataset input dataset #5
         * @param s6Dataset input dataset #6
         * @return output dataset
         */
        Dataset<D> apply(
                Dataset<S1> s1Dataset,
                Dataset<S2> s2Dataset,
                Dataset<S3> s3Dataset,
                Dataset<S4> s4Dataset,
                Dataset<S5> s5Dataset,
                Dataset<S6> s6Dataset
        );

        /**
         * This utility method allows to chain a transformation on the output dataset. The transformation may maintain or change the output type.
         *
         * @param tx   transformation to apply on the output
         * @param <D2> type of the output after this transformation is applied
         * @return output dataset after the transformation
         */
        default <D2> Data6Transformation<S1, S2, S3, S4, S5, S6, D2> andThen(DataTransformation<D, D2> tx) {
            return (s1, s2, s3, s4, s5, s6) -> tx.apply(apply(s1, s2, s3, s4, s5, s6));
        }

        /**
         * This utility method applies an encoder to the output dataset.
         *
         * @param encoder encoder to apply
         * @param <D2>    type of the output after this encoding is applied
         * @return output dataset after the encoding
         */
        default <D2> Data6Transformation<S1, S2, S3, S4, S5, S6, D2> andThenEncode(Encoder<D2> encoder) {
            return andThen(Transformations.encode(encoder));
        }

    }

    /**
     * DataSource that stores information needed to perform a custom-defined operation on 6 input DataSources
     *
     * @param <S1> type of the input DataSource #1
     * @param <S2> type of the input DataSource #2
     * @param <S3> type of the input DataSource #3
     * @param <S4> type of the input DataSource #4
     * @param <S5> type of the input DataSource #5
     * @param <S6> type of the input DataSource #6
     * @param <D>  type of the output DataSource
     */
    @Value
    @Builder
    public static class DataSource6<S1, S2, S3, S4, S5, S6, D> implements DataSource<D> {

        @Nonnull
        DataSource<S1> parentDataSource1;
        @Nonnull
        DataSource<S2> parentDataSource2;
        @Nonnull
        DataSource<S3> parentDataSource3;
        @Nonnull
        DataSource<S4> parentDataSource4;
        @Nonnull
        DataSource<S5> parentDataSource5;
        @Nonnull
        DataSource<S6> parentDataSource6;
        @Nonnull
        Data6Transformation<S1, S2, S3, S4, S5, S6, D> transformation;

        @Override
        public Dataset<D> get() {
            return transformation.apply(
                    parentDataSource1.get(),
                    parentDataSource2.get(),
                    parentDataSource3.get(),
                    parentDataSource4.get(),
                    parentDataSource5.get(),
                    parentDataSource6.get()
            );
        }
    }

    /**
     * Creates a DataSource that performs an on-demand merge transformation between all the input DataSources.
     *
     * @param source1  input DataSource #1
     * @param source2  input DataSource #2
     * @param source3  input DataSource #3
     * @param source4  input DataSource #4
     * @param source5  input DataSource #5
     * @param source6  input DataSource #6
     * @param merger transformation to apply
     * @param <S1>   type of the input DataSource #1
     * @param <S2>   type of the input DataSource #2
     * @param <S3>   type of the input DataSource #3
     * @param <S4>   type of the input DataSource #4
     * @param <S5>   type of the input DataSource #5
     * @param <S6>   type of the input DataSource #6
     * @param <D>    type of the output DataSource
     * @return outcome of the merge operation
     */
    public static <S1, S2, S3, S4, S5, S6, D> DataSource<D> mergeAll(
            DataSource<S1> source1,
            DataSource<S2> source2,
            DataSource<S3> source3,
            DataSource<S4> source4,
            DataSource<S5> source5,
            DataSource<S6> source6,
            Data6Transformation<S1, S2, S3, S4, S5, S6, D> merger) {
        return DataSource6.<S1, S2, S3, S4, S5, S6, D>builder()
                .parentDataSource1(source1)
                .parentDataSource2(source2)
                .parentDataSource3(source3)
                .parentDataSource4(source4)
                .parentDataSource5(source5)
                .parentDataSource6(source6)
                .transformation(merger)
                .build();
    }

    /**
     * Data transformation interface that performs a custom-defined operation on 3 input Datasets
     *
     * @param <S1> type of the input dataset #1
     * @param <S2> type of the input dataset #2
     * @param <S3> type of the input dataset #3
     * @param <S4> type of the input dataset #4
     * @param <S5> type of the input dataset #5
     * @param <S6> type of the input dataset #6
     * @param <S7> type of the input dataset #7
     * @param <D>  type of the output dataset
     */
    public interface Data7Transformation<S1, S2, S3, S4, S5, S6, S7, D> {

        /**
         * Applies the transformation.
         *
         * @param s1Dataset input dataset #1
         * @param s2Dataset input dataset #2
         * @param s3Dataset input dataset #3
         * @param s4Dataset input dataset #4
         * @param s5Dataset input dataset #5
         * @param s6Dataset input dataset #6
         * @param s7Dataset input dataset #7
         * @return output dataset
         */
        Dataset<D> apply(
                Dataset<S1> s1Dataset,
                Dataset<S2> s2Dataset,
                Dataset<S3> s3Dataset,
                Dataset<S4> s4Dataset,
                Dataset<S5> s5Dataset,
                Dataset<S6> s6Dataset,
                Dataset<S7> s7Dataset
        );

        /**
         * This utility method allows to chain a transformation on the output dataset. The transformation may maintain or change the output type.
         *
         * @param tx   transformation to apply on the output
         * @param <D2> type of the output after this transformation is applied
         * @return output dataset after the transformation
         */
        default <D2> Data7Transformation<S1, S2, S3, S4, S5, S6, S7, D2> andThen(DataTransformation<D, D2> tx) {
            return (s1, s2, s3, s4, s5, s6, s7) -> tx.apply(apply(s1, s2, s3, s4, s5, s6, s7));
        }

        /**
         * This utility method applies an encoder to the output dataset.
         *
         * @param encoder encoder to apply
         * @param <D2>    type of the output after this encoding is applied
         * @return output dataset after the encoding
         */
        default <D2> Data7Transformation<S1, S2, S3, S4, S5, S6, S7, D2> andThenEncode(Encoder<D2> encoder) {
            return andThen(Transformations.encode(encoder));
        }

    }

    /**
     * DataSource that stores information needed to perform a custom-defined operation on 7 input DataSources
     *
     * @param <S1> type of the input DataSource #1
     * @param <S2> type of the input DataSource #2
     * @param <S3> type of the input DataSource #3
     * @param <S4> type of the input DataSource #4
     * @param <S5> type of the input DataSource #5
     * @param <S6> type of the input DataSource #6
     * @param <S7> type of the input DataSource #7
     * @param <D>  type of the output DataSource
     */
    @Value
    @Builder
    public static class DataSource7<S1, S2, S3, S4, S5, S6, S7, D> implements DataSource<D> {

        @Nonnull
        DataSource<S1> parentDataSource1;
        @Nonnull
        DataSource<S2> parentDataSource2;
        @Nonnull
        DataSource<S3> parentDataSource3;
        @Nonnull
        DataSource<S4> parentDataSource4;
        @Nonnull
        DataSource<S5> parentDataSource5;
        @Nonnull
        DataSource<S6> parentDataSource6;
        @Nonnull
        DataSource<S7> parentDataSource7;
        @Nonnull
        Data7Transformation<S1, S2, S3, S4, S5, S6, S7, D> transformation;

        @Override
        public Dataset<D> get() {
            return transformation.apply(
                    parentDataSource1.get(),
                    parentDataSource2.get(),
                    parentDataSource3.get(),
                    parentDataSource4.get(),
                    parentDataSource5.get(),
                    parentDataSource6.get(),
                    parentDataSource7.get()
            );
        }
    }

    /**
     * Creates a DataSource that performs an on-demand merge transformation between all the input DataSources.
     *
     * @param source1  input DataSource #1
     * @param source2  input DataSource #2
     * @param source3  input DataSource #3
     * @param source4  input DataSource #4
     * @param source5  input DataSource #5
     * @param source6  input DataSource #6
     * @param source7  input DataSource #7
     * @param merger transformation to apply
     * @param <S1>   type of the input DataSource #1
     * @param <S2>   type of the input DataSource #2
     * @param <S3>   type of the input DataSource #3
     * @param <S4>   type of the input DataSource #4
     * @param <S5>   type of the input DataSource #5
     * @param <S6>   type of the input DataSource #6
     * @param <S7>   type of the input DataSource #7
     * @param <D>    type of the output DataSource
     * @return outcome of the merge operation
     */
    public static <S1, S2, S3, S4, S5, S6, S7, D> DataSource<D> mergeAll(
            DataSource<S1> source1,
            DataSource<S2> source2,
            DataSource<S3> source3,
            DataSource<S4> source4,
            DataSource<S5> source5,
            DataSource<S6> source6,
            DataSource<S7> source7,
            Data7Transformation<S1, S2, S3, S4, S5, S6, S7, D> merger) {
        return DataSource7.<S1, S2, S3, S4, S5, S6, S7, D>builder()
                .parentDataSource1(source1)
                .parentDataSource2(source2)
                .parentDataSource3(source3)
                .parentDataSource4(source4)
                .parentDataSource5(source5)
                .parentDataSource6(source6)
                .parentDataSource7(source7)
                .transformation(merger)
                .build();
    }

    /**
     * Data transformation interface that performs a custom-defined operation on 3 input Datasets
     *
     * @param <S1> type of the input dataset #1
     * @param <S2> type of the input dataset #2
     * @param <S3> type of the input dataset #3
     * @param <S4> type of the input dataset #4
     * @param <S5> type of the input dataset #5
     * @param <S6> type of the input dataset #6
     * @param <S7> type of the input dataset #7
     * @param <S8> type of the input dataset #8
     * @param <D>  type of the output dataset
     */
    public interface Data8Transformation<S1, S2, S3, S4, S5, S6, S7, S8, D> {

        /**
         * Applies the transformation.
         *
         * @param s1Dataset input dataset #1
         * @param s2Dataset input dataset #2
         * @param s3Dataset input dataset #3
         * @param s4Dataset input dataset #4
         * @param s5Dataset input dataset #5
         * @param s6Dataset input dataset #6
         * @param s7Dataset input dataset #7
         * @param s8Dataset input dataset #8
         * @return output dataset
         */
        Dataset<D> apply(
                Dataset<S1> s1Dataset,
                Dataset<S2> s2Dataset,
                Dataset<S3> s3Dataset,
                Dataset<S4> s4Dataset,
                Dataset<S5> s5Dataset,
                Dataset<S6> s6Dataset,
                Dataset<S7> s7Dataset,
                Dataset<S8> s8Dataset
        );

        /**
         * This utility method allows to chain a transformation on the output dataset. The transformation may maintain or change the output type.
         *
         * @param tx   transformation to apply on the output
         * @param <D2> type of the output after this transformation is applied
         * @return output dataset after the transformation
         */
        default <D2> Data8Transformation<S1, S2, S3, S4, S5, S6, S7, S8, D2> andThen(DataTransformation<D, D2> tx) {
            return (s1, s2, s3, s4, s5, s6, s7, s8) -> tx.apply(apply(s1, s2, s3, s4, s5, s6, s7, s8));
        }

        /**
         * This utility method applies an encoder to the output dataset.
         *
         * @param encoder encoder to apply
         * @param <D2>    type of the output after this encoding is applied
         * @return output dataset after the encoding
         */
        default <D2> Data8Transformation<S1, S2, S3, S4, S5, S6, S7, S8, D2> andThenEncode(Encoder<D2> encoder) {
            return andThen(Transformations.encode(encoder));
        }

    }

    /**
     * DataSource that stores information needed to perform a custom-defined operation on 8 input DataSources
     *
     * @param <S1> type of the input DataSource #1
     * @param <S2> type of the input DataSource #2
     * @param <S3> type of the input DataSource #3
     * @param <S4> type of the input DataSource #4
     * @param <S5> type of the input DataSource #5
     * @param <S6> type of the input DataSource #6
     * @param <S7> type of the input DataSource #7
     * @param <S8> type of the input DataSource #8
     * @param <D>  type of the output DataSource
     */
    @Value
    @Builder
    public static class DataSource8<S1, S2, S3, S4, S5, S6, S7, S8, D> implements DataSource<D> {

        @Nonnull
        DataSource<S1> parentDataSource1;
        @Nonnull
        DataSource<S2> parentDataSource2;
        @Nonnull
        DataSource<S3> parentDataSource3;
        @Nonnull
        DataSource<S4> parentDataSource4;
        @Nonnull
        DataSource<S5> parentDataSource5;
        @Nonnull
        DataSource<S6> parentDataSource6;
        @Nonnull
        DataSource<S7> parentDataSource7;
        @Nonnull
        DataSource<S8> parentDataSource8;
        @Nonnull
        Data8Transformation<S1, S2, S3, S4, S5, S6, S7, S8, D> transformation;

        @Override
        public Dataset<D> get() {
            return transformation.apply(
                    parentDataSource1.get(),
                    parentDataSource2.get(),
                    parentDataSource3.get(),
                    parentDataSource4.get(),
                    parentDataSource5.get(),
                    parentDataSource6.get(),
                    parentDataSource7.get(),
                    parentDataSource8.get()
            );
        }
    }

    /**
     * Creates a DataSource that performs an on-demand merge transformation between all the input DataSources.
     *
     * @param source1  input DataSource #1
     * @param source2  input DataSource #2
     * @param source3  input DataSource #3
     * @param source4  input DataSource #4
     * @param source5  input DataSource #5
     * @param source6  input DataSource #6
     * @param source7  input DataSource #7
     * @param source8  input DataSource #8
     * @param merger transformation to apply
     * @param <S1>   type of the input DataSource #1
     * @param <S2>   type of the input DataSource #2
     * @param <S3>   type of the input DataSource #3
     * @param <S4>   type of the input DataSource #4
     * @param <S5>   type of the input DataSource #5
     * @param <S6>   type of the input DataSource #6
     * @param <S7>   type of the input DataSource #7
     * @param <S8>   type of the input DataSource #8
     * @param <D>    type of the output DataSource
     * @return outcome of the merge operation
     */
    public static <S1, S2, S3, S4, S5, S6, S7, S8, D> DataSource<D> mergeAll(
            DataSource<S1> source1,
            DataSource<S2> source2,
            DataSource<S3> source3,
            DataSource<S4> source4,
            DataSource<S5> source5,
            DataSource<S6> source6,
            DataSource<S7> source7,
            DataSource<S8> source8,
            Data8Transformation<S1, S2, S3, S4, S5, S6, S7, S8, D> merger) {
        return DataSource8.<S1, S2, S3, S4, S5, S6, S7, S8, D>builder()
                .parentDataSource1(source1)
                .parentDataSource2(source2)
                .parentDataSource3(source3)
                .parentDataSource4(source4)
                .parentDataSource5(source5)
                .parentDataSource6(source6)
                .parentDataSource7(source7)
                .parentDataSource8(source8)
                .transformation(merger)
                .build();
    }

    /**
     * Data transformation interface that performs a custom-defined operation on 3 input Datasets
     *
     * @param <S1> type of the input dataset #1
     * @param <S2> type of the input dataset #2
     * @param <S3> type of the input dataset #3
     * @param <S4> type of the input dataset #4
     * @param <S5> type of the input dataset #5
     * @param <S6> type of the input dataset #6
     * @param <S7> type of the input dataset #7
     * @param <S8> type of the input dataset #8
     * @param <S9> type of the input dataset #9
     * @param <D>  type of the output dataset
     */
    public interface Data9Transformation<S1, S2, S3, S4, S5, S6, S7, S8, S9, D> {

        /**
         * Applies the transformation.
         *
         * @param s1Dataset input dataset #1
         * @param s2Dataset input dataset #2
         * @param s3Dataset input dataset #3
         * @param s4Dataset input dataset #4
         * @param s5Dataset input dataset #5
         * @param s6Dataset input dataset #6
         * @param s7Dataset input dataset #7
         * @param s8Dataset input dataset #8
         * @param s9Dataset input dataset #9
         * @return output dataset
         */
        Dataset<D> apply(
                Dataset<S1> s1Dataset,
                Dataset<S2> s2Dataset,
                Dataset<S3> s3Dataset,
                Dataset<S4> s4Dataset,
                Dataset<S5> s5Dataset,
                Dataset<S6> s6Dataset,
                Dataset<S7> s7Dataset,
                Dataset<S8> s8Dataset,
                Dataset<S9> s9Dataset
        );

        /**
         * This utility method allows to chain a transformation on the output dataset. The transformation may maintain or change the output type.
         *
         * @param tx   transformation to apply on the output
         * @param <D2> type of the output after this transformation is applied
         * @return output dataset after the transformation
         */
        default <D2> Data9Transformation<S1, S2, S3, S4, S5, S6, S7, S8, S9, D2> andThen(DataTransformation<D, D2> tx) {
            return (s1, s2, s3, s4, s5, s6, s7, s8, s9) -> tx.apply(apply(s1, s2, s3, s4, s5, s6, s7, s8, s9));
        }

        /**
         * This utility method applies an encoder to the output dataset.
         *
         * @param encoder encoder to apply
         * @param <D2>    type of the output after this encoding is applied
         * @return output dataset after the encoding
         */
        default <D2> Data9Transformation<S1, S2, S3, S4, S5, S6, S7, S8, S9, D2> andThenEncode(Encoder<D2> encoder) {
            return andThen(Transformations.encode(encoder));
        }

    }

    /**
     * DataSource that stores information needed to perform a custom-defined operation on 9 input DataSources
     *
     * @param <S1> type of the input DataSource #1
     * @param <S2> type of the input DataSource #2
     * @param <S3> type of the input DataSource #3
     * @param <S4> type of the input DataSource #4
     * @param <S5> type of the input DataSource #5
     * @param <S6> type of the input DataSource #6
     * @param <S7> type of the input DataSource #7
     * @param <S8> type of the input DataSource #8
     * @param <S9> type of the input DataSource #9
     * @param <D>  type of the output DataSource
     */
    @Value
    @Builder
    public static class DataSource9<S1, S2, S3, S4, S5, S6, S7, S8, S9, D> implements DataSource<D> {

        @Nonnull
        DataSource<S1> parentDataSource1;
        @Nonnull
        DataSource<S2> parentDataSource2;
        @Nonnull
        DataSource<S3> parentDataSource3;
        @Nonnull
        DataSource<S4> parentDataSource4;
        @Nonnull
        DataSource<S5> parentDataSource5;
        @Nonnull
        DataSource<S6> parentDataSource6;
        @Nonnull
        DataSource<S7> parentDataSource7;
        @Nonnull
        DataSource<S8> parentDataSource8;
        @Nonnull
        DataSource<S9> parentDataSource9;
        @Nonnull
        Data9Transformation<S1, S2, S3, S4, S5, S6, S7, S8, S9, D> transformation;

        @Override
        public Dataset<D> get() {
            return transformation.apply(
                    parentDataSource1.get(),
                    parentDataSource2.get(),
                    parentDataSource3.get(),
                    parentDataSource4.get(),
                    parentDataSource5.get(),
                    parentDataSource6.get(),
                    parentDataSource7.get(),
                    parentDataSource8.get(),
                    parentDataSource9.get()
            );
        }
    }

    /**
     * Creates a DataSource that performs an on-demand merge transformation between all the input DataSources.
     *
     * @param source1  input DataSource #1
     * @param source2  input DataSource #2
     * @param source3  input DataSource #3
     * @param source4  input DataSource #4
     * @param source5  input DataSource #5
     * @param source6  input DataSource #6
     * @param source7  input DataSource #7
     * @param source8  input DataSource #8
     * @param source9  input DataSource #9
     * @param merger transformation to apply
     * @param <S1>   type of the input DataSource #1
     * @param <S2>   type of the input DataSource #2
     * @param <S3>   type of the input DataSource #3
     * @param <S4>   type of the input DataSource #4
     * @param <S5>   type of the input DataSource #5
     * @param <S6>   type of the input DataSource #6
     * @param <S7>   type of the input DataSource #7
     * @param <S8>   type of the input DataSource #8
     * @param <S9>   type of the input DataSource #9
     * @param <D>    type of the output DataSource
     * @return outcome of the merge operation
     */
    public static <S1, S2, S3, S4, S5, S6, S7, S8, S9, D> DataSource<D> mergeAll(
            DataSource<S1> source1,
            DataSource<S2> source2,
            DataSource<S3> source3,
            DataSource<S4> source4,
            DataSource<S5> source5,
            DataSource<S6> source6,
            DataSource<S7> source7,
            DataSource<S8> source8,
            DataSource<S9> source9,
            Data9Transformation<S1, S2, S3, S4, S5, S6, S7, S8, S9, D> merger) {
        return DataSource9.<S1, S2, S3, S4, S5, S6, S7, S8, S9, D>builder()
                .parentDataSource1(source1)
                .parentDataSource2(source2)
                .parentDataSource3(source3)
                .parentDataSource4(source4)
                .parentDataSource5(source5)
                .parentDataSource6(source6)
                .parentDataSource7(source7)
                .parentDataSource8(source8)
                .parentDataSource9(source9)
                .transformation(merger)
                .build();
    }

    /**
     * Data transformation interface that performs a custom-defined operation on 3 input Datasets
     *
     * @param <S1> type of the input dataset #1
     * @param <S2> type of the input dataset #2
     * @param <S3> type of the input dataset #3
     * @param <S4> type of the input dataset #4
     * @param <S5> type of the input dataset #5
     * @param <S6> type of the input dataset #6
     * @param <S7> type of the input dataset #7
     * @param <S8> type of the input dataset #8
     * @param <S9> type of the input dataset #9
     * @param <S10> type of the input dataset #10
     * @param <D>  type of the output dataset
     */
    public interface Data10Transformation<S1, S2, S3, S4, S5, S6, S7, S8, S9, S10, D> {

        /**
         * Applies the transformation.
         *
         * @param s1Dataset input dataset #1
         * @param s2Dataset input dataset #2
         * @param s3Dataset input dataset #3
         * @param s4Dataset input dataset #4
         * @param s5Dataset input dataset #5
         * @param s6Dataset input dataset #6
         * @param s7Dataset input dataset #7
         * @param s8Dataset input dataset #8
         * @param s9Dataset input dataset #9
         * @param s10Dataset input dataset #10
         * @return output dataset
         */
        Dataset<D> apply(
                Dataset<S1> s1Dataset,
                Dataset<S2> s2Dataset,
                Dataset<S3> s3Dataset,
                Dataset<S4> s4Dataset,
                Dataset<S5> s5Dataset,
                Dataset<S6> s6Dataset,
                Dataset<S7> s7Dataset,
                Dataset<S8> s8Dataset,
                Dataset<S9> s9Dataset,
                Dataset<S10> s10Dataset
        );

        /**
         * This utility method allows to chain a transformation on the output dataset. The transformation may maintain or change the output type.
         *
         * @param tx   transformation to apply on the output
         * @param <D2> type of the output after this transformation is applied
         * @return output dataset after the transformation
         */
        default <D2> Data10Transformation<S1, S2, S3, S4, S5, S6, S7, S8, S9, S10, D2> andThen(DataTransformation<D, D2> tx) {
            return (s1, s2, s3, s4, s5, s6, s7, s8, s9, s10) -> tx.apply(apply(s1, s2, s3, s4, s5, s6, s7, s8, s9, s10));
        }

        /**
         * This utility method applies an encoder to the output dataset.
         *
         * @param encoder encoder to apply
         * @param <D2>    type of the output after this encoding is applied
         * @return output dataset after the encoding
         */
        default <D2> Data10Transformation<S1, S2, S3, S4, S5, S6, S7, S8, S9, S10, D2> andThenEncode(Encoder<D2> encoder) {
            return andThen(Transformations.encode(encoder));
        }

    }

    /**
     * DataSource that stores information needed to perform a custom-defined operation on 10 input DataSources
     *
     * @param <S1> type of the input DataSource #1
     * @param <S2> type of the input DataSource #2
     * @param <S3> type of the input DataSource #3
     * @param <S4> type of the input DataSource #4
     * @param <S5> type of the input DataSource #5
     * @param <S6> type of the input DataSource #6
     * @param <S7> type of the input DataSource #7
     * @param <S8> type of the input DataSource #8
     * @param <S9> type of the input DataSource #9
     * @param <S10> type of the input DataSource #10
     * @param <D>  type of the output DataSource
     */
    @Value
    @Builder
    public static class DataSource10<S1, S2, S3, S4, S5, S6, S7, S8, S9, S10, D> implements DataSource<D> {

        @Nonnull
        DataSource<S1> parentDataSource1;
        @Nonnull
        DataSource<S2> parentDataSource2;
        @Nonnull
        DataSource<S3> parentDataSource3;
        @Nonnull
        DataSource<S4> parentDataSource4;
        @Nonnull
        DataSource<S5> parentDataSource5;
        @Nonnull
        DataSource<S6> parentDataSource6;
        @Nonnull
        DataSource<S7> parentDataSource7;
        @Nonnull
        DataSource<S8> parentDataSource8;
        @Nonnull
        DataSource<S9> parentDataSource9;
        @Nonnull
        DataSource<S10> parentDataSource10;
        @Nonnull
        Data10Transformation<S1, S2, S3, S4, S5, S6, S7, S8, S9, S10, D> transformation;

        @Override
        public Dataset<D> get() {
            return transformation.apply(
                    parentDataSource1.get(),
                    parentDataSource2.get(),
                    parentDataSource3.get(),
                    parentDataSource4.get(),
                    parentDataSource5.get(),
                    parentDataSource6.get(),
                    parentDataSource7.get(),
                    parentDataSource8.get(),
                    parentDataSource9.get(),
                    parentDataSource10.get()
            );
        }
    }

    /**
     * Creates a DataSource that performs an on-demand merge transformation between all the input DataSources.
     *
     * @param source1  input DataSource #1
     * @param source2  input DataSource #2
     * @param source3  input DataSource #3
     * @param source4  input DataSource #4
     * @param source5  input DataSource #5
     * @param source6  input DataSource #6
     * @param source7  input DataSource #7
     * @param source8  input DataSource #8
     * @param source9  input DataSource #9
     * @param source10  input DataSource #10
     * @param merger transformation to apply
     * @param <S1>   type of the input DataSource #1
     * @param <S2>   type of the input DataSource #2
     * @param <S3>   type of the input DataSource #3
     * @param <S4>   type of the input DataSource #4
     * @param <S5>   type of the input DataSource #5
     * @param <S6>   type of the input DataSource #6
     * @param <S7>   type of the input DataSource #7
     * @param <S8>   type of the input DataSource #8
     * @param <S9>   type of the input DataSource #9
     * @param <S10>   type of the input DataSource #10
     * @param <D>    type of the output DataSource
     * @return outcome of the merge operation
     */
    public static <S1, S2, S3, S4, S5, S6, S7, S8, S9, S10, D> DataSource<D> mergeAll(
            DataSource<S1> source1,
            DataSource<S2> source2,
            DataSource<S3> source3,
            DataSource<S4> source4,
            DataSource<S5> source5,
            DataSource<S6> source6,
            DataSource<S7> source7,
            DataSource<S8> source8,
            DataSource<S9> source9,
            DataSource<S10> source10,
            Data10Transformation<S1, S2, S3, S4, S5, S6, S7, S8, S9, S10, D> merger) {
        return DataSource10.<S1, S2, S3, S4, S5, S6, S7, S8, S9, S10, D>builder()
                .parentDataSource1(source1)
                .parentDataSource2(source2)
                .parentDataSource3(source3)
                .parentDataSource4(source4)
                .parentDataSource5(source5)
                .parentDataSource6(source6)
                .parentDataSource7(source7)
                .parentDataSource8(source8)
                .parentDataSource9(source9)
                .parentDataSource10(source10)
                .transformation(merger)
                .build();
    }

}
