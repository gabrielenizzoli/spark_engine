package dataengine.pipeline.transformation;

import dataengine.pipeline.Data2Transformation;
import dataengine.pipeline.DataSource;
import dataengine.pipeline.DataTransformation;
import dataengine.pipeline.transformation.Transformations;
import org.apache.spark.sql.Dataset;
import org.apache.spark.sql.Encoder;

public class MergeTransformations {

    public static <S1, S2, D> DataSource<D> mergeAll(
            DataSource<S1> source1, DataSource<S2> source2,
            Data2Transformation<S1, S2, D> merger) {
        return source1.mergeWith(source2, merger);
    }

    // start of code generated by a utility

    /**
     * Data transformation interface that performs a custom-defined operation on 3 input Datasets
     *
     * @param <S1> type of the input dataset #1
     * @param <S2> type of the input dataset #2
     * @param <S3> type of the input dataset #3
     * @param <D>  type of the output dataset
     */
    public interface Data3Transformation<S1, S2, S3, D> {

        /**
         * Applies the transformation.
         *
         * @param s1Dataset input dataset #1
         * @param s2Dataset input dataset #2
         * @param s3Dataset input dataset #3
         * @return output dataset
         */
        Dataset<D> apply(
                Dataset<S1> s1Dataset,
                Dataset<S2> s2Dataset,
                Dataset<S3> s3Dataset
        );

        /**
         * This utility method allows to chain a transformation on the output dataset. The transformation may maintain or change the output type.
         *
         * @param tx   transformation to apply on the output
         * @param <D2> type of the output after this transformation is applied
         * @return output dataset after the transformation
         */
        default <D2> Data3Transformation<S1, S2, S3, D2> andThen(DataTransformation<D, D2> tx) {
            return (s1, s2, s3) -> tx.apply(apply(s1, s2, s3));
        }

        /**
         * This utility method applies an encoder to the output dataset.
         *
         * @param encoder encoder to apply
         * @param <D2>    type of the output after this encoding is applied
         * @return output dataset after the encoding
         */
        default <D2> Data3Transformation<S1, S2, S3, D2> andThenEncode(Encoder<D2> encoder) {
            return andThen(Transformations.encode(encoder));
        }

    }

    /**
     * Applies a merge transformation to all the input DataPipes.
     *
     * @param source1  input DataSource #1
     * @param source2  input DataSource #2
     * @param source3  input DataSource #3
     * @param merger transformation to apply
     * @param <S1>   type of the input DataSource #1
     * @param <S2>   type of the input DataSource #2
     * @param <S3>   type of the input DataSource #3
     * @param <D>    type of the output DataSource
     * @return outcome of the merge operation
     */
    public static <S1, S2, S3, D> DataSource<D> mergeAll(
            DataSource<S1> source1,
            DataSource<S2> source2,
            DataSource<S3> source3,
            Data3Transformation<S1, S2, S3, D> merger) {
        return () -> merger.apply(source1.get(), source2.get(), source3.get());
    }

    /**
     * Data transformation interface that performs a custom-defined operation on 3 input Datasets
     *
     * @param <S1> type of the input dataset #1
     * @param <S2> type of the input dataset #2
     * @param <S3> type of the input dataset #3
     * @param <S4> type of the input dataset #4
     * @param <D>  type of the output dataset
     */
    public interface Data4Transformation<S1, S2, S3, S4, D> {

        /**
         * Applies the transformation.
         *
         * @param s1Dataset input dataset #1
         * @param s2Dataset input dataset #2
         * @param s3Dataset input dataset #3
         * @param s4Dataset input dataset #4
         * @return output dataset
         */
        Dataset<D> apply(
                Dataset<S1> s1Dataset,
                Dataset<S2> s2Dataset,
                Dataset<S3> s3Dataset,
                Dataset<S4> s4Dataset
        );

        /**
         * This utility method allows to chain a transformation on the output dataset. The transformation may maintain or change the output type.
         *
         * @param tx   transformation to apply on the output
         * @param <D2> type of the output after this transformation is applied
         * @return output dataset after the transformation
         */
        default <D2> Data4Transformation<S1, S2, S3, S4, D2> andThen(DataTransformation<D, D2> tx) {
            return (s1, s2, s3, s4) -> tx.apply(apply(s1, s2, s3, s4));
        }

        /**
         * This utility method applies an encoder to the output dataset.
         *
         * @param encoder encoder to apply
         * @param <D2>    type of the output after this encoding is applied
         * @return output dataset after the encoding
         */
        default <D2> Data4Transformation<S1, S2, S3, S4, D2> andThenEncode(Encoder<D2> encoder) {
            return andThen(Transformations.encode(encoder));
        }

    }

    /**
     * Applies a merge transformation to all the input DataPipes.
     *
     * @param source1  input DataSource #1
     * @param source2  input DataSource #2
     * @param source3  input DataSource #3
     * @param source4  input DataSource #4
     * @param merger transformation to apply
     * @param <S1>   type of the input DataSource #1
     * @param <S2>   type of the input DataSource #2
     * @param <S3>   type of the input DataSource #3
     * @param <S4>   type of the input DataSource #4
     * @param <D>    type of the output DataSource
     * @return outcome of the merge operation
     */
    public static <S1, S2, S3, S4, D> DataSource<D> mergeAll(
            DataSource<S1> source1,
            DataSource<S2> source2,
            DataSource<S3> source3,
            DataSource<S4> source4,
            Data4Transformation<S1, S2, S3, S4, D> merger) {
        return () -> merger.apply(source1.get(), source2.get(), source3.get(), source4.get());
    }

    /**
     * Data transformation interface that performs a custom-defined operation on 3 input Datasets
     *
     * @param <S1> type of the input dataset #1
     * @param <S2> type of the input dataset #2
     * @param <S3> type of the input dataset #3
     * @param <S4> type of the input dataset #4
     * @param <S5> type of the input dataset #5
     * @param <D>  type of the output dataset
     */
    public interface Data5Transformation<S1, S2, S3, S4, S5, D> {

        /**
         * Applies the transformation.
         *
         * @param s1Dataset input dataset #1
         * @param s2Dataset input dataset #2
         * @param s3Dataset input dataset #3
         * @param s4Dataset input dataset #4
         * @param s5Dataset input dataset #5
         * @return output dataset
         */
        Dataset<D> apply(
                Dataset<S1> s1Dataset,
                Dataset<S2> s2Dataset,
                Dataset<S3> s3Dataset,
                Dataset<S4> s4Dataset,
                Dataset<S5> s5Dataset
        );

        /**
         * This utility method allows to chain a transformation on the output dataset. The transformation may maintain or change the output type.
         *
         * @param tx   transformation to apply on the output
         * @param <D2> type of the output after this transformation is applied
         * @return output dataset after the transformation
         */
        default <D2> Data5Transformation<S1, S2, S3, S4, S5, D2> andThen(DataTransformation<D, D2> tx) {
            return (s1, s2, s3, s4, s5) -> tx.apply(apply(s1, s2, s3, s4, s5));
        }

        /**
         * This utility method applies an encoder to the output dataset.
         *
         * @param encoder encoder to apply
         * @param <D2>    type of the output after this encoding is applied
         * @return output dataset after the encoding
         */
        default <D2> Data5Transformation<S1, S2, S3, S4, S5, D2> andThenEncode(Encoder<D2> encoder) {
            return andThen(Transformations.encode(encoder));
        }

    }

    /**
     * Applies a merge transformation to all the input DataPipes.
     *
     * @param source1  input DataSource #1
     * @param source2  input DataSource #2
     * @param source3  input DataSource #3
     * @param source4  input DataSource #4
     * @param source5  input DataSource #5
     * @param merger transformation to apply
     * @param <S1>   type of the input DataSource #1
     * @param <S2>   type of the input DataSource #2
     * @param <S3>   type of the input DataSource #3
     * @param <S4>   type of the input DataSource #4
     * @param <S5>   type of the input DataSource #5
     * @param <D>    type of the output DataSource
     * @return outcome of the merge operation
     */
    public static <S1, S2, S3, S4, S5, D> DataSource<D> mergeAll(
            DataSource<S1> source1,
            DataSource<S2> source2,
            DataSource<S3> source3,
            DataSource<S4> source4,
            DataSource<S5> source5,
            Data5Transformation<S1, S2, S3, S4, S5, D> merger) {
        return () -> merger.apply(source1.get(), source2.get(), source3.get(), source4.get(), source5.get());
    }

    /**
     * Data transformation interface that performs a custom-defined operation on 3 input Datasets
     *
     * @param <S1> type of the input dataset #1
     * @param <S2> type of the input dataset #2
     * @param <S3> type of the input dataset #3
     * @param <S4> type of the input dataset #4
     * @param <S5> type of the input dataset #5
     * @param <S6> type of the input dataset #6
     * @param <D>  type of the output dataset
     */
    public interface Data6Transformation<S1, S2, S3, S4, S5, S6, D> {

        /**
         * Applies the transformation.
         *
         * @param s1Dataset input dataset #1
         * @param s2Dataset input dataset #2
         * @param s3Dataset input dataset #3
         * @param s4Dataset input dataset #4
         * @param s5Dataset input dataset #5
         * @param s6Dataset input dataset #6
         * @return output dataset
         */
        Dataset<D> apply(
                Dataset<S1> s1Dataset,
                Dataset<S2> s2Dataset,
                Dataset<S3> s3Dataset,
                Dataset<S4> s4Dataset,
                Dataset<S5> s5Dataset,
                Dataset<S6> s6Dataset
        );

        /**
         * This utility method allows to chain a transformation on the output dataset. The transformation may maintain or change the output type.
         *
         * @param tx   transformation to apply on the output
         * @param <D2> type of the output after this transformation is applied
         * @return output dataset after the transformation
         */
        default <D2> Data6Transformation<S1, S2, S3, S4, S5, S6, D2> andThen(DataTransformation<D, D2> tx) {
            return (s1, s2, s3, s4, s5, s6) -> tx.apply(apply(s1, s2, s3, s4, s5, s6));
        }

        /**
         * This utility method applies an encoder to the output dataset.
         *
         * @param encoder encoder to apply
         * @param <D2>    type of the output after this encoding is applied
         * @return output dataset after the encoding
         */
        default <D2> Data6Transformation<S1, S2, S3, S4, S5, S6, D2> andThenEncode(Encoder<D2> encoder) {
            return andThen(Transformations.encode(encoder));
        }

    }

    /**
     * Applies a merge transformation to all the input DataPipes.
     *
     * @param source1  input DataSource #1
     * @param source2  input DataSource #2
     * @param source3  input DataSource #3
     * @param source4  input DataSource #4
     * @param source5  input DataSource #5
     * @param source6  input DataSource #6
     * @param merger transformation to apply
     * @param <S1>   type of the input DataSource #1
     * @param <S2>   type of the input DataSource #2
     * @param <S3>   type of the input DataSource #3
     * @param <S4>   type of the input DataSource #4
     * @param <S5>   type of the input DataSource #5
     * @param <S6>   type of the input DataSource #6
     * @param <D>    type of the output DataSource
     * @return outcome of the merge operation
     */
    public static <S1, S2, S3, S4, S5, S6, D> DataSource<D> mergeAll(
            DataSource<S1> source1,
            DataSource<S2> source2,
            DataSource<S3> source3,
            DataSource<S4> source4,
            DataSource<S5> source5,
            DataSource<S6> source6,
            Data6Transformation<S1, S2, S3, S4, S5, S6, D> merger) {
        return () -> merger.apply(source1.get(), source2.get(), source3.get(), source4.get(), source5.get(), source6.get());
    }

    /**
     * Data transformation interface that performs a custom-defined operation on 3 input Datasets
     *
     * @param <S1> type of the input dataset #1
     * @param <S2> type of the input dataset #2
     * @param <S3> type of the input dataset #3
     * @param <S4> type of the input dataset #4
     * @param <S5> type of the input dataset #5
     * @param <S6> type of the input dataset #6
     * @param <S7> type of the input dataset #7
     * @param <D>  type of the output dataset
     */
    public interface Data7Transformation<S1, S2, S3, S4, S5, S6, S7, D> {

        /**
         * Applies the transformation.
         *
         * @param s1Dataset input dataset #1
         * @param s2Dataset input dataset #2
         * @param s3Dataset input dataset #3
         * @param s4Dataset input dataset #4
         * @param s5Dataset input dataset #5
         * @param s6Dataset input dataset #6
         * @param s7Dataset input dataset #7
         * @return output dataset
         */
        Dataset<D> apply(
                Dataset<S1> s1Dataset,
                Dataset<S2> s2Dataset,
                Dataset<S3> s3Dataset,
                Dataset<S4> s4Dataset,
                Dataset<S5> s5Dataset,
                Dataset<S6> s6Dataset,
                Dataset<S7> s7Dataset
        );

        /**
         * This utility method allows to chain a transformation on the output dataset. The transformation may maintain or change the output type.
         *
         * @param tx   transformation to apply on the output
         * @param <D2> type of the output after this transformation is applied
         * @return output dataset after the transformation
         */
        default <D2> Data7Transformation<S1, S2, S3, S4, S5, S6, S7, D2> andThen(DataTransformation<D, D2> tx) {
            return (s1, s2, s3, s4, s5, s6, s7) -> tx.apply(apply(s1, s2, s3, s4, s5, s6, s7));
        }

        /**
         * This utility method applies an encoder to the output dataset.
         *
         * @param encoder encoder to apply
         * @param <D2>    type of the output after this encoding is applied
         * @return output dataset after the encoding
         */
        default <D2> Data7Transformation<S1, S2, S3, S4, S5, S6, S7, D2> andThenEncode(Encoder<D2> encoder) {
            return andThen(Transformations.encode(encoder));
        }

    }

    /**
     * Applies a merge transformation to all the input DataPipes.
     *
     * @param source1  input DataSource #1
     * @param source2  input DataSource #2
     * @param source3  input DataSource #3
     * @param source4  input DataSource #4
     * @param source5  input DataSource #5
     * @param source6  input DataSource #6
     * @param source7  input DataSource #7
     * @param merger transformation to apply
     * @param <S1>   type of the input DataSource #1
     * @param <S2>   type of the input DataSource #2
     * @param <S3>   type of the input DataSource #3
     * @param <S4>   type of the input DataSource #4
     * @param <S5>   type of the input DataSource #5
     * @param <S6>   type of the input DataSource #6
     * @param <S7>   type of the input DataSource #7
     * @param <D>    type of the output DataSource
     * @return outcome of the merge operation
     */
    public static <S1, S2, S3, S4, S5, S6, S7, D> DataSource<D> mergeAll(
            DataSource<S1> source1,
            DataSource<S2> source2,
            DataSource<S3> source3,
            DataSource<S4> source4,
            DataSource<S5> source5,
            DataSource<S6> source6,
            DataSource<S7> source7,
            Data7Transformation<S1, S2, S3, S4, S5, S6, S7, D> merger) {
        return () -> merger.apply(source1.get(), source2.get(), source3.get(), source4.get(), source5.get(), source6.get(), source7.get());
    }

    /**
     * Data transformation interface that performs a custom-defined operation on 3 input Datasets
     *
     * @param <S1> type of the input dataset #1
     * @param <S2> type of the input dataset #2
     * @param <S3> type of the input dataset #3
     * @param <S4> type of the input dataset #4
     * @param <S5> type of the input dataset #5
     * @param <S6> type of the input dataset #6
     * @param <S7> type of the input dataset #7
     * @param <S8> type of the input dataset #8
     * @param <D>  type of the output dataset
     */
    public interface Data8Transformation<S1, S2, S3, S4, S5, S6, S7, S8, D> {

        /**
         * Applies the transformation.
         *
         * @param s1Dataset input dataset #1
         * @param s2Dataset input dataset #2
         * @param s3Dataset input dataset #3
         * @param s4Dataset input dataset #4
         * @param s5Dataset input dataset #5
         * @param s6Dataset input dataset #6
         * @param s7Dataset input dataset #7
         * @param s8Dataset input dataset #8
         * @return output dataset
         */
        Dataset<D> apply(
                Dataset<S1> s1Dataset,
                Dataset<S2> s2Dataset,
                Dataset<S3> s3Dataset,
                Dataset<S4> s4Dataset,
                Dataset<S5> s5Dataset,
                Dataset<S6> s6Dataset,
                Dataset<S7> s7Dataset,
                Dataset<S8> s8Dataset
        );

        /**
         * This utility method allows to chain a transformation on the output dataset. The transformation may maintain or change the output type.
         *
         * @param tx   transformation to apply on the output
         * @param <D2> type of the output after this transformation is applied
         * @return output dataset after the transformation
         */
        default <D2> Data8Transformation<S1, S2, S3, S4, S5, S6, S7, S8, D2> andThen(DataTransformation<D, D2> tx) {
            return (s1, s2, s3, s4, s5, s6, s7, s8) -> tx.apply(apply(s1, s2, s3, s4, s5, s6, s7, s8));
        }

        /**
         * This utility method applies an encoder to the output dataset.
         *
         * @param encoder encoder to apply
         * @param <D2>    type of the output after this encoding is applied
         * @return output dataset after the encoding
         */
        default <D2> Data8Transformation<S1, S2, S3, S4, S5, S6, S7, S8, D2> andThenEncode(Encoder<D2> encoder) {
            return andThen(Transformations.encode(encoder));
        }

    }

    /**
     * Applies a merge transformation to all the input DataPipes.
     *
     * @param source1  input DataSource #1
     * @param source2  input DataSource #2
     * @param source3  input DataSource #3
     * @param source4  input DataSource #4
     * @param source5  input DataSource #5
     * @param source6  input DataSource #6
     * @param source7  input DataSource #7
     * @param source8  input DataSource #8
     * @param merger transformation to apply
     * @param <S1>   type of the input DataSource #1
     * @param <S2>   type of the input DataSource #2
     * @param <S3>   type of the input DataSource #3
     * @param <S4>   type of the input DataSource #4
     * @param <S5>   type of the input DataSource #5
     * @param <S6>   type of the input DataSource #6
     * @param <S7>   type of the input DataSource #7
     * @param <S8>   type of the input DataSource #8
     * @param <D>    type of the output DataSource
     * @return outcome of the merge operation
     */
    public static <S1, S2, S3, S4, S5, S6, S7, S8, D> DataSource<D> mergeAll(
            DataSource<S1> source1,
            DataSource<S2> source2,
            DataSource<S3> source3,
            DataSource<S4> source4,
            DataSource<S5> source5,
            DataSource<S6> source6,
            DataSource<S7> source7,
            DataSource<S8> source8,
            Data8Transformation<S1, S2, S3, S4, S5, S6, S7, S8, D> merger) {
        return () -> merger.apply(source1.get(), source2.get(), source3.get(), source4.get(), source5.get(), source6.get(), source7.get(), source8.get());
    }

    /**
     * Data transformation interface that performs a custom-defined operation on 3 input Datasets
     *
     * @param <S1> type of the input dataset #1
     * @param <S2> type of the input dataset #2
     * @param <S3> type of the input dataset #3
     * @param <S4> type of the input dataset #4
     * @param <S5> type of the input dataset #5
     * @param <S6> type of the input dataset #6
     * @param <S7> type of the input dataset #7
     * @param <S8> type of the input dataset #8
     * @param <S9> type of the input dataset #9
     * @param <D>  type of the output dataset
     */
    public interface Data9Transformation<S1, S2, S3, S4, S5, S6, S7, S8, S9, D> {

        /**
         * Applies the transformation.
         *
         * @param s1Dataset input dataset #1
         * @param s2Dataset input dataset #2
         * @param s3Dataset input dataset #3
         * @param s4Dataset input dataset #4
         * @param s5Dataset input dataset #5
         * @param s6Dataset input dataset #6
         * @param s7Dataset input dataset #7
         * @param s8Dataset input dataset #8
         * @param s9Dataset input dataset #9
         * @return output dataset
         */
        Dataset<D> apply(
                Dataset<S1> s1Dataset,
                Dataset<S2> s2Dataset,
                Dataset<S3> s3Dataset,
                Dataset<S4> s4Dataset,
                Dataset<S5> s5Dataset,
                Dataset<S6> s6Dataset,
                Dataset<S7> s7Dataset,
                Dataset<S8> s8Dataset,
                Dataset<S9> s9Dataset
        );

        /**
         * This utility method allows to chain a transformation on the output dataset. The transformation may maintain or change the output type.
         *
         * @param tx   transformation to apply on the output
         * @param <D2> type of the output after this transformation is applied
         * @return output dataset after the transformation
         */
        default <D2> Data9Transformation<S1, S2, S3, S4, S5, S6, S7, S8, S9, D2> andThen(DataTransformation<D, D2> tx) {
            return (s1, s2, s3, s4, s5, s6, s7, s8, s9) -> tx.apply(apply(s1, s2, s3, s4, s5, s6, s7, s8, s9));
        }

        /**
         * This utility method applies an encoder to the output dataset.
         *
         * @param encoder encoder to apply
         * @param <D2>    type of the output after this encoding is applied
         * @return output dataset after the encoding
         */
        default <D2> Data9Transformation<S1, S2, S3, S4, S5, S6, S7, S8, S9, D2> andThenEncode(Encoder<D2> encoder) {
            return andThen(Transformations.encode(encoder));
        }

    }

    /**
     * Applies a merge transformation to all the input DataPipes.
     *
     * @param source1  input DataSource #1
     * @param source2  input DataSource #2
     * @param source3  input DataSource #3
     * @param source4  input DataSource #4
     * @param source5  input DataSource #5
     * @param source6  input DataSource #6
     * @param source7  input DataSource #7
     * @param source8  input DataSource #8
     * @param source9  input DataSource #9
     * @param merger transformation to apply
     * @param <S1>   type of the input DataSource #1
     * @param <S2>   type of the input DataSource #2
     * @param <S3>   type of the input DataSource #3
     * @param <S4>   type of the input DataSource #4
     * @param <S5>   type of the input DataSource #5
     * @param <S6>   type of the input DataSource #6
     * @param <S7>   type of the input DataSource #7
     * @param <S8>   type of the input DataSource #8
     * @param <S9>   type of the input DataSource #9
     * @param <D>    type of the output DataSource
     * @return outcome of the merge operation
     */
    public static <S1, S2, S3, S4, S5, S6, S7, S8, S9, D> DataSource<D> mergeAll(
            DataSource<S1> source1,
            DataSource<S2> source2,
            DataSource<S3> source3,
            DataSource<S4> source4,
            DataSource<S5> source5,
            DataSource<S6> source6,
            DataSource<S7> source7,
            DataSource<S8> source8,
            DataSource<S9> source9,
            Data9Transformation<S1, S2, S3, S4, S5, S6, S7, S8, S9, D> merger) {
        return () -> merger.apply(source1.get(), source2.get(), source3.get(), source4.get(), source5.get(), source6.get(), source7.get(), source8.get(), source9.get());
    }

    /**
     * Data transformation interface that performs a custom-defined operation on 3 input Datasets
     *
     * @param <S1> type of the input dataset #1
     * @param <S2> type of the input dataset #2
     * @param <S3> type of the input dataset #3
     * @param <S4> type of the input dataset #4
     * @param <S5> type of the input dataset #5
     * @param <S6> type of the input dataset #6
     * @param <S7> type of the input dataset #7
     * @param <S8> type of the input dataset #8
     * @param <S9> type of the input dataset #9
     * @param <S10> type of the input dataset #10
     * @param <D>  type of the output dataset
     */
    public interface Data10Transformation<S1, S2, S3, S4, S5, S6, S7, S8, S9, S10, D> {

        /**
         * Applies the transformation.
         *
         * @param s1Dataset input dataset #1
         * @param s2Dataset input dataset #2
         * @param s3Dataset input dataset #3
         * @param s4Dataset input dataset #4
         * @param s5Dataset input dataset #5
         * @param s6Dataset input dataset #6
         * @param s7Dataset input dataset #7
         * @param s8Dataset input dataset #8
         * @param s9Dataset input dataset #9
         * @param s10Dataset input dataset #10
         * @return output dataset
         */
        Dataset<D> apply(
                Dataset<S1> s1Dataset,
                Dataset<S2> s2Dataset,
                Dataset<S3> s3Dataset,
                Dataset<S4> s4Dataset,
                Dataset<S5> s5Dataset,
                Dataset<S6> s6Dataset,
                Dataset<S7> s7Dataset,
                Dataset<S8> s8Dataset,
                Dataset<S9> s9Dataset,
                Dataset<S10> s10Dataset
        );

        /**
         * This utility method allows to chain a transformation on the output dataset. The transformation may maintain or change the output type.
         *
         * @param tx   transformation to apply on the output
         * @param <D2> type of the output after this transformation is applied
         * @return output dataset after the transformation
         */
        default <D2> Data10Transformation<S1, S2, S3, S4, S5, S6, S7, S8, S9, S10, D2> andThen(DataTransformation<D, D2> tx) {
            return (s1, s2, s3, s4, s5, s6, s7, s8, s9, s10) -> tx.apply(apply(s1, s2, s3, s4, s5, s6, s7, s8, s9, s10));
        }

        /**
         * This utility method applies an encoder to the output dataset.
         *
         * @param encoder encoder to apply
         * @param <D2>    type of the output after this encoding is applied
         * @return output dataset after the encoding
         */
        default <D2> Data10Transformation<S1, S2, S3, S4, S5, S6, S7, S8, S9, S10, D2> andThenEncode(Encoder<D2> encoder) {
            return andThen(Transformations.encode(encoder));
        }

    }

    /**
     * Applies a merge transformation to all the input DataPipes.
     *
     * @param source1  input DataSource #1
     * @param source2  input DataSource #2
     * @param source3  input DataSource #3
     * @param source4  input DataSource #4
     * @param source5  input DataSource #5
     * @param source6  input DataSource #6
     * @param source7  input DataSource #7
     * @param source8  input DataSource #8
     * @param source9  input DataSource #9
     * @param source10  input DataSource #10
     * @param merger transformation to apply
     * @param <S1>   type of the input DataSource #1
     * @param <S2>   type of the input DataSource #2
     * @param <S3>   type of the input DataSource #3
     * @param <S4>   type of the input DataSource #4
     * @param <S5>   type of the input DataSource #5
     * @param <S6>   type of the input DataSource #6
     * @param <S7>   type of the input DataSource #7
     * @param <S8>   type of the input DataSource #8
     * @param <S9>   type of the input DataSource #9
     * @param <S10>   type of the input DataSource #10
     * @param <D>    type of the output DataSource
     * @return outcome of the merge operation
     */
    public static <S1, S2, S3, S4, S5, S6, S7, S8, S9, S10, D> DataSource<D> mergeAll(
            DataSource<S1> source1,
            DataSource<S2> source2,
            DataSource<S3> source3,
            DataSource<S4> source4,
            DataSource<S5> source5,
            DataSource<S6> source6,
            DataSource<S7> source7,
            DataSource<S8> source8,
            DataSource<S9> source9,
            DataSource<S10> source10,
            Data10Transformation<S1, S2, S3, S4, S5, S6, S7, S8, S9, S10, D> merger) {
        return () -> merger.apply(source1.get(), source2.get(), source3.get(), source4.get(), source5.get(), source6.get(), source7.get(), source8.get(), source9.get(), source10.get());
    }



}
