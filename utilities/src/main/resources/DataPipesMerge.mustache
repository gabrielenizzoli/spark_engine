    // start of code generated by a utility

{{#merges}}
    /**
     * Data transformation interface that performs a custom-defined operation on 3 input Datasets
     *
     {{#i}}
     * @param <S{{this}}> type of the input dataset #{{this}}
     {{/i}}
     * @param <D>  type of the output dataset
     */
    public interface Data{{number}}Transformation<{{#i}}{{^-first}}, {{/-first}}S{{this}}{{/i}}, D> {

        /**
         * Applies the transformation.
         *
         {{#i}}
         * @param s{{this}}Dataset input dataset #{{this}}
         {{/i}}
         * @return output dataset
         */
        Dataset<D> apply(
        {{#i}}
                        Dataset<S{{this}}> s{{this}}Dataset{{^-last}}, {{/-last}}
        {{/i}}
                        );

        /**
         * This utility method allows to chain a transformation on the output dataset. The transformation may maintain or change the output type.
         *
         * @param tx   transformation to apply on the output
         * @param <D2> type of the output after this transformation is applied
         * @return output dataset after the transformation
         */
        default <D2> Data{{number}}Transformation<{{#i}}{{^-first}}, {{/-first}}S{{this}}{{/i}}, D2> andThen(DataTransformation<D, D2> tx) {
            return ({{#i}}{{^-first}}, {{/-first}}s{{this}}{{/i}}) -> tx.apply(apply({{#i}}{{^-first}}, {{/-first}}s{{this}}{{/i}}));
        }

        /**
         * This utility method applies an encoder to the output dataset.
         *
         * @param encoder encoder to apply
         * @param <D2>    type of the output after this encoding is applied
         * @return output dataset after the encoding
         */
        default <D2> Data{{number}}Transformation<{{#i}}{{^-first}}, {{/-first}}S{{this}}{{/i}}, D2> andThenEncode(Encoder<D2> encoder) {
            return andThen(Transformations.encode(encoder));
        }

    }

    /**
     * DataSource that stores information needed to perform a custom-defined operation on {{number}} input DataSources
     *
     {{#i}}
     * @param <S{{this}}> type of the input DataSource #{{this}}
     {{/i}}
     * @param <D>  type of the output DataSource
     */
    @Value
    @Builder
    public static class DataSource{{number}}<{{#i}}{{^-first}}, {{/-first}}S{{this}}{{/i}}, D> implements DataSource<D> {

        {{#i}}
        @Nonnull
        DataSource<S{{this}}> parentDataSource{{this}};
        {{/i}}
        @Nonnull
        Data{{number}}Transformation<{{#i}}{{^-first}}, {{/-first}}S{{this}}{{/i}}, D> transformation;

        @Override
        public Dataset<D> get() {
            return transformation.apply(
                {{#i}}
                parentDataSource{{this}}.get(){{^-last}},{{/-last}}
                {{/i}}
            );
        }
    }

    /**
     * Creates a DataSource that performs an on-demand merge transformation between all the input DataSources.
     *
     {{#i}}
     * @param source{{this}}  input DataSource #{{this}}
     {{/i}}
     * @param merger transformation to apply
     {{#i}}
     * @param <S{{this}}>   type of the input DataSource #{{this}}
     {{/i}}
     * @param <D>    type of the output DataSource
     * @return outcome of the merge operation
     */
    public static <{{#i}}{{^-first}}, {{/-first}}S{{this}}{{/i}}, D> DataSource<D> mergeAll(
    {{#i}}
           DataSource<S{{this}}> source{{this}},
    {{/i}}
            Data{{number}}Transformation<{{#i}}{{^-first}}, {{/-first}}S{{this}}{{/i}}, D> merger) {
        return DataSource{{number}}.<{{#i}}{{^-first}}, {{/-first}}S{{this}}{{/i}}, D>builder()
           {{#i}}
           .parentDataSource{{this}}(source{{this}})
           {{/i}}
           .transformation(merger)
           .build();
    }

{{/merges}}