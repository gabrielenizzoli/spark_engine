package dataengine.pipelines;

import dataengine.pipelines.transformations.Transformations;
import org.apache.spark.sql.Dataset;
import org.apache.spark.sql.Encoder;

public class DataPipes {

    public static <S1, S2, D> DataPipe<D> mergeAll(
            DataPipe<S1> pipe1, DataPipe<S2> pipe2,
            Data2Transformation<S1, S2, D> merger) {
        return pipe1.mergeWith(pipe2, merger);
    }

    // start of code generated by a utility

    /**
     * Data transformation interface that performs a custom-defined operation on 3 input Datasets
     *
     * @param <S1> type of the input dataset #1
     * @param <S2> type of the input dataset #2
     * @param <S3> type of the input dataset #3
     * @param <D>  type of the output dataset
     */
    public interface Data3Transformation<S1, S2, S3, D> {

        /**
         * Applies the transformation.
         *
         * @param s1Dataset input dataset #1
         * @param s2Dataset input dataset #2
         * @param s3Dataset input dataset #3
         * @return output dataset
         */
        Dataset<D> apply(
                Dataset<S1> s1Dataset,
                Dataset<S2> s2Dataset,
                Dataset<S3> s3Dataset
        );

        /**
         * This utility method allows to chain a transformation on the output dataset. The transformation may maintain or change the output type.
         *
         * @param tx   transformation to apply on the output
         * @param <D2> type of the output after this transformation is applied
         * @return output dataset after the transformation
         */
        default <D2> Data3Transformation<S1, S2, S3, D2> andThen(DataTransformation<D, D2> tx) {
            return (s1, s2, s3) -> tx.apply(apply(s1, s2, s3));
        }

        /**
         * This utility method applies an encoder to the output dataset.
         *
         * @param encoder encoder to apply
         * @param <D2>    type of the output after this encoding is applied
         * @return output dataset after the encoding
         */
        default <D2> Data3Transformation<S1, S2, S3, D2> andThenEncode(Encoder<D2> encoder) {
            return andThen(Transformations.encode(encoder));
        }

    }

    /**
     * Applies a merge transformation to all the input DataPipes.
     *
     * @param pipe1  input DataPipe #1
     * @param pipe2  input DataPipe #2
     * @param pipe3  input DataPipe #3
     * @param merger transformation to apply
     * @param <S1>   type of the input DataPipe #1
     * @param <S2>   type of the input DataPipe #2
     * @param <S3>   type of the input DataPipe #3
     * @param <D>    type of the output DataPipe
     * @return outcome of the merge operation
     */
    public static <S1, S2, S3, D> DataPipe<D> mergeAll(
            DataPipe<S1> pipe1,
            DataPipe<S2> pipe2,
            DataPipe<S3> pipe3,
            Data3Transformation<S1, S2, S3, D> merger) {
        Dataset<D> mergedDataset = merger.apply(pipe1.dataset, pipe2.dataset, pipe3.dataset);
        return new DataPipe<>(mergedDataset);
    }

    /**
     * Data transformation interface that performs a custom-defined operation on 3 input Datasets
     *
     * @param <S1> type of the input dataset #1
     * @param <S2> type of the input dataset #2
     * @param <S3> type of the input dataset #3
     * @param <S4> type of the input dataset #4
     * @param <D>  type of the output dataset
     */
    public interface Data4Transformation<S1, S2, S3, S4, D> {

        /**
         * Applies the transformation.
         *
         * @param s1Dataset input dataset #1
         * @param s2Dataset input dataset #2
         * @param s3Dataset input dataset #3
         * @param s4Dataset input dataset #4
         * @return output dataset
         */
        Dataset<D> apply(
                Dataset<S1> s1Dataset,
                Dataset<S2> s2Dataset,
                Dataset<S3> s3Dataset,
                Dataset<S4> s4Dataset
        );

        /**
         * This utility method allows to chain a transformation on the output dataset. The transformation may maintain or change the output type.
         *
         * @param tx   transformation to apply on the output
         * @param <D2> type of the output after this transformation is applied
         * @return output dataset after the transformation
         */
        default <D2> Data4Transformation<S1, S2, S3, S4, D2> andThen(DataTransformation<D, D2> tx) {
            return (s1, s2, s3, s4) -> tx.apply(apply(s1, s2, s3, s4));
        }

        /**
         * This utility method applies an encoder to the output dataset.
         *
         * @param encoder encoder to apply
         * @param <D2>    type of the output after this encoding is applied
         * @return output dataset after the encoding
         */
        default <D2> Data4Transformation<S1, S2, S3, S4, D2> andThenEncode(Encoder<D2> encoder) {
            return andThen(Transformations.encode(encoder));
        }

    }

    /**
     * Applies a merge transformation to all the input DataPipes.
     *
     * @param pipe1  input DataPipe #1
     * @param pipe2  input DataPipe #2
     * @param pipe3  input DataPipe #3
     * @param pipe4  input DataPipe #4
     * @param merger transformation to apply
     * @param <S1>   type of the input DataPipe #1
     * @param <S2>   type of the input DataPipe #2
     * @param <S3>   type of the input DataPipe #3
     * @param <S4>   type of the input DataPipe #4
     * @param <D>    type of the output DataPipe
     * @return outcome of the merge operation
     */
    public static <S1, S2, S3, S4, D> DataPipe<D> mergeAll(
            DataPipe<S1> pipe1,
            DataPipe<S2> pipe2,
            DataPipe<S3> pipe3,
            DataPipe<S4> pipe4,
            Data4Transformation<S1, S2, S3, S4, D> merger) {
        Dataset<D> mergedDataset = merger.apply(pipe1.dataset, pipe2.dataset, pipe3.dataset, pipe4.dataset);
        return new DataPipe<>(mergedDataset);
    }

    /**
     * Data transformation interface that performs a custom-defined operation on 3 input Datasets
     *
     * @param <S1> type of the input dataset #1
     * @param <S2> type of the input dataset #2
     * @param <S3> type of the input dataset #3
     * @param <S4> type of the input dataset #4
     * @param <S5> type of the input dataset #5
     * @param <D>  type of the output dataset
     */
    public interface Data5Transformation<S1, S2, S3, S4, S5, D> {

        /**
         * Applies the transformation.
         *
         * @param s1Dataset input dataset #1
         * @param s2Dataset input dataset #2
         * @param s3Dataset input dataset #3
         * @param s4Dataset input dataset #4
         * @param s5Dataset input dataset #5
         * @return output dataset
         */
        Dataset<D> apply(
                Dataset<S1> s1Dataset,
                Dataset<S2> s2Dataset,
                Dataset<S3> s3Dataset,
                Dataset<S4> s4Dataset,
                Dataset<S5> s5Dataset
        );

        /**
         * This utility method allows to chain a transformation on the output dataset. The transformation may maintain or change the output type.
         *
         * @param tx   transformation to apply on the output
         * @param <D2> type of the output after this transformation is applied
         * @return output dataset after the transformation
         */
        default <D2> Data5Transformation<S1, S2, S3, S4, S5, D2> andThen(DataTransformation<D, D2> tx) {
            return (s1, s2, s3, s4, s5) -> tx.apply(apply(s1, s2, s3, s4, s5));
        }

        /**
         * This utility method applies an encoder to the output dataset.
         *
         * @param encoder encoder to apply
         * @param <D2>    type of the output after this encoding is applied
         * @return output dataset after the encoding
         */
        default <D2> Data5Transformation<S1, S2, S3, S4, S5, D2> andThenEncode(Encoder<D2> encoder) {
            return andThen(Transformations.encode(encoder));
        }

    }

    /**
     * Applies a merge transformation to all the input DataPipes.
     *
     * @param pipe1  input DataPipe #1
     * @param pipe2  input DataPipe #2
     * @param pipe3  input DataPipe #3
     * @param pipe4  input DataPipe #4
     * @param pipe5  input DataPipe #5
     * @param merger transformation to apply
     * @param <S1>   type of the input DataPipe #1
     * @param <S2>   type of the input DataPipe #2
     * @param <S3>   type of the input DataPipe #3
     * @param <S4>   type of the input DataPipe #4
     * @param <S5>   type of the input DataPipe #5
     * @param <D>    type of the output DataPipe
     * @return outcome of the merge operation
     */
    public static <S1, S2, S3, S4, S5, D> DataPipe<D> mergeAll(
            DataPipe<S1> pipe1,
            DataPipe<S2> pipe2,
            DataPipe<S3> pipe3,
            DataPipe<S4> pipe4,
            DataPipe<S5> pipe5,
            Data5Transformation<S1, S2, S3, S4, S5, D> merger) {
        Dataset<D> mergedDataset = merger.apply(pipe1.dataset, pipe2.dataset, pipe3.dataset, pipe4.dataset, pipe5.dataset);
        return new DataPipe<>(mergedDataset);
    }

    /**
     * Data transformation interface that performs a custom-defined operation on 3 input Datasets
     *
     * @param <S1> type of the input dataset #1
     * @param <S2> type of the input dataset #2
     * @param <S3> type of the input dataset #3
     * @param <S4> type of the input dataset #4
     * @param <S5> type of the input dataset #5
     * @param <S6> type of the input dataset #6
     * @param <D>  type of the output dataset
     */
    public interface Data6Transformation<S1, S2, S3, S4, S5, S6, D> {

        /**
         * Applies the transformation.
         *
         * @param s1Dataset input dataset #1
         * @param s2Dataset input dataset #2
         * @param s3Dataset input dataset #3
         * @param s4Dataset input dataset #4
         * @param s5Dataset input dataset #5
         * @param s6Dataset input dataset #6
         * @return output dataset
         */
        Dataset<D> apply(
                Dataset<S1> s1Dataset,
                Dataset<S2> s2Dataset,
                Dataset<S3> s3Dataset,
                Dataset<S4> s4Dataset,
                Dataset<S5> s5Dataset,
                Dataset<S6> s6Dataset
        );

        /**
         * This utility method allows to chain a transformation on the output dataset. The transformation may maintain or change the output type.
         *
         * @param tx   transformation to apply on the output
         * @param <D2> type of the output after this transformation is applied
         * @return output dataset after the transformation
         */
        default <D2> Data6Transformation<S1, S2, S3, S4, S5, S6, D2> andThen(DataTransformation<D, D2> tx) {
            return (s1, s2, s3, s4, s5, s6) -> tx.apply(apply(s1, s2, s3, s4, s5, s6));
        }

        /**
         * This utility method applies an encoder to the output dataset.
         *
         * @param encoder encoder to apply
         * @param <D2>    type of the output after this encoding is applied
         * @return output dataset after the encoding
         */
        default <D2> Data6Transformation<S1, S2, S3, S4, S5, S6, D2> andThenEncode(Encoder<D2> encoder) {
            return andThen(Transformations.encode(encoder));
        }

    }

    /**
     * Applies a merge transformation to all the input DataPipes.
     *
     * @param pipe1  input DataPipe #1
     * @param pipe2  input DataPipe #2
     * @param pipe3  input DataPipe #3
     * @param pipe4  input DataPipe #4
     * @param pipe5  input DataPipe #5
     * @param pipe6  input DataPipe #6
     * @param merger transformation to apply
     * @param <S1>   type of the input DataPipe #1
     * @param <S2>   type of the input DataPipe #2
     * @param <S3>   type of the input DataPipe #3
     * @param <S4>   type of the input DataPipe #4
     * @param <S5>   type of the input DataPipe #5
     * @param <S6>   type of the input DataPipe #6
     * @param <D>    type of the output DataPipe
     * @return outcome of the merge operation
     */
    public static <S1, S2, S3, S4, S5, S6, D> DataPipe<D> mergeAll(
            DataPipe<S1> pipe1,
            DataPipe<S2> pipe2,
            DataPipe<S3> pipe3,
            DataPipe<S4> pipe4,
            DataPipe<S5> pipe5,
            DataPipe<S6> pipe6,
            Data6Transformation<S1, S2, S3, S4, S5, S6, D> merger) {
        Dataset<D> mergedDataset = merger.apply(pipe1.dataset, pipe2.dataset, pipe3.dataset, pipe4.dataset, pipe5.dataset, pipe6.dataset);
        return new DataPipe<>(mergedDataset);
    }

    /**
     * Data transformation interface that performs a custom-defined operation on 3 input Datasets
     *
     * @param <S1> type of the input dataset #1
     * @param <S2> type of the input dataset #2
     * @param <S3> type of the input dataset #3
     * @param <S4> type of the input dataset #4
     * @param <S5> type of the input dataset #5
     * @param <S6> type of the input dataset #6
     * @param <S7> type of the input dataset #7
     * @param <D>  type of the output dataset
     */
    public interface Data7Transformation<S1, S2, S3, S4, S5, S6, S7, D> {

        /**
         * Applies the transformation.
         *
         * @param s1Dataset input dataset #1
         * @param s2Dataset input dataset #2
         * @param s3Dataset input dataset #3
         * @param s4Dataset input dataset #4
         * @param s5Dataset input dataset #5
         * @param s6Dataset input dataset #6
         * @param s7Dataset input dataset #7
         * @return output dataset
         */
        Dataset<D> apply(
                Dataset<S1> s1Dataset,
                Dataset<S2> s2Dataset,
                Dataset<S3> s3Dataset,
                Dataset<S4> s4Dataset,
                Dataset<S5> s5Dataset,
                Dataset<S6> s6Dataset,
                Dataset<S7> s7Dataset
        );

        /**
         * This utility method allows to chain a transformation on the output dataset. The transformation may maintain or change the output type.
         *
         * @param tx   transformation to apply on the output
         * @param <D2> type of the output after this transformation is applied
         * @return output dataset after the transformation
         */
        default <D2> Data7Transformation<S1, S2, S3, S4, S5, S6, S7, D2> andThen(DataTransformation<D, D2> tx) {
            return (s1, s2, s3, s4, s5, s6, s7) -> tx.apply(apply(s1, s2, s3, s4, s5, s6, s7));
        }

        /**
         * This utility method applies an encoder to the output dataset.
         *
         * @param encoder encoder to apply
         * @param <D2>    type of the output after this encoding is applied
         * @return output dataset after the encoding
         */
        default <D2> Data7Transformation<S1, S2, S3, S4, S5, S6, S7, D2> andThenEncode(Encoder<D2> encoder) {
            return andThen(Transformations.encode(encoder));
        }

    }

    /**
     * Applies a merge transformation to all the input DataPipes.
     *
     * @param pipe1  input DataPipe #1
     * @param pipe2  input DataPipe #2
     * @param pipe3  input DataPipe #3
     * @param pipe4  input DataPipe #4
     * @param pipe5  input DataPipe #5
     * @param pipe6  input DataPipe #6
     * @param pipe7  input DataPipe #7
     * @param merger transformation to apply
     * @param <S1>   type of the input DataPipe #1
     * @param <S2>   type of the input DataPipe #2
     * @param <S3>   type of the input DataPipe #3
     * @param <S4>   type of the input DataPipe #4
     * @param <S5>   type of the input DataPipe #5
     * @param <S6>   type of the input DataPipe #6
     * @param <S7>   type of the input DataPipe #7
     * @param <D>    type of the output DataPipe
     * @return outcome of the merge operation
     */
    public static <S1, S2, S3, S4, S5, S6, S7, D> DataPipe<D> mergeAll(
            DataPipe<S1> pipe1,
            DataPipe<S2> pipe2,
            DataPipe<S3> pipe3,
            DataPipe<S4> pipe4,
            DataPipe<S5> pipe5,
            DataPipe<S6> pipe6,
            DataPipe<S7> pipe7,
            Data7Transformation<S1, S2, S3, S4, S5, S6, S7, D> merger) {
        Dataset<D> mergedDataset = merger.apply(pipe1.dataset, pipe2.dataset, pipe3.dataset, pipe4.dataset, pipe5.dataset, pipe6.dataset, pipe7.dataset);
        return new DataPipe<>(mergedDataset);
    }

    /**
     * Data transformation interface that performs a custom-defined operation on 3 input Datasets
     *
     * @param <S1> type of the input dataset #1
     * @param <S2> type of the input dataset #2
     * @param <S3> type of the input dataset #3
     * @param <S4> type of the input dataset #4
     * @param <S5> type of the input dataset #5
     * @param <S6> type of the input dataset #6
     * @param <S7> type of the input dataset #7
     * @param <S8> type of the input dataset #8
     * @param <D>  type of the output dataset
     */
    public interface Data8Transformation<S1, S2, S3, S4, S5, S6, S7, S8, D> {

        /**
         * Applies the transformation.
         *
         * @param s1Dataset input dataset #1
         * @param s2Dataset input dataset #2
         * @param s3Dataset input dataset #3
         * @param s4Dataset input dataset #4
         * @param s5Dataset input dataset #5
         * @param s6Dataset input dataset #6
         * @param s7Dataset input dataset #7
         * @param s8Dataset input dataset #8
         * @return output dataset
         */
        Dataset<D> apply(
                Dataset<S1> s1Dataset,
                Dataset<S2> s2Dataset,
                Dataset<S3> s3Dataset,
                Dataset<S4> s4Dataset,
                Dataset<S5> s5Dataset,
                Dataset<S6> s6Dataset,
                Dataset<S7> s7Dataset,
                Dataset<S8> s8Dataset
        );

        /**
         * This utility method allows to chain a transformation on the output dataset. The transformation may maintain or change the output type.
         *
         * @param tx   transformation to apply on the output
         * @param <D2> type of the output after this transformation is applied
         * @return output dataset after the transformation
         */
        default <D2> Data8Transformation<S1, S2, S3, S4, S5, S6, S7, S8, D2> andThen(DataTransformation<D, D2> tx) {
            return (s1, s2, s3, s4, s5, s6, s7, s8) -> tx.apply(apply(s1, s2, s3, s4, s5, s6, s7, s8));
        }

        /**
         * This utility method applies an encoder to the output dataset.
         *
         * @param encoder encoder to apply
         * @param <D2>    type of the output after this encoding is applied
         * @return output dataset after the encoding
         */
        default <D2> Data8Transformation<S1, S2, S3, S4, S5, S6, S7, S8, D2> andThenEncode(Encoder<D2> encoder) {
            return andThen(Transformations.encode(encoder));
        }

    }

    /**
     * Applies a merge transformation to all the input DataPipes.
     *
     * @param pipe1  input DataPipe #1
     * @param pipe2  input DataPipe #2
     * @param pipe3  input DataPipe #3
     * @param pipe4  input DataPipe #4
     * @param pipe5  input DataPipe #5
     * @param pipe6  input DataPipe #6
     * @param pipe7  input DataPipe #7
     * @param pipe8  input DataPipe #8
     * @param merger transformation to apply
     * @param <S1>   type of the input DataPipe #1
     * @param <S2>   type of the input DataPipe #2
     * @param <S3>   type of the input DataPipe #3
     * @param <S4>   type of the input DataPipe #4
     * @param <S5>   type of the input DataPipe #5
     * @param <S6>   type of the input DataPipe #6
     * @param <S7>   type of the input DataPipe #7
     * @param <S8>   type of the input DataPipe #8
     * @param <D>    type of the output DataPipe
     * @return outcome of the merge operation
     */
    public static <S1, S2, S3, S4, S5, S6, S7, S8, D> DataPipe<D> mergeAll(
            DataPipe<S1> pipe1,
            DataPipe<S2> pipe2,
            DataPipe<S3> pipe3,
            DataPipe<S4> pipe4,
            DataPipe<S5> pipe5,
            DataPipe<S6> pipe6,
            DataPipe<S7> pipe7,
            DataPipe<S8> pipe8,
            Data8Transformation<S1, S2, S3, S4, S5, S6, S7, S8, D> merger) {
        Dataset<D> mergedDataset = merger.apply(pipe1.dataset, pipe2.dataset, pipe3.dataset, pipe4.dataset, pipe5.dataset, pipe6.dataset, pipe7.dataset, pipe8.dataset);
        return new DataPipe<>(mergedDataset);
    }

    /**
     * Data transformation interface that performs a custom-defined operation on 3 input Datasets
     *
     * @param <S1> type of the input dataset #1
     * @param <S2> type of the input dataset #2
     * @param <S3> type of the input dataset #3
     * @param <S4> type of the input dataset #4
     * @param <S5> type of the input dataset #5
     * @param <S6> type of the input dataset #6
     * @param <S7> type of the input dataset #7
     * @param <S8> type of the input dataset #8
     * @param <S9> type of the input dataset #9
     * @param <D>  type of the output dataset
     */
    public interface Data9Transformation<S1, S2, S3, S4, S5, S6, S7, S8, S9, D> {

        /**
         * Applies the transformation.
         *
         * @param s1Dataset input dataset #1
         * @param s2Dataset input dataset #2
         * @param s3Dataset input dataset #3
         * @param s4Dataset input dataset #4
         * @param s5Dataset input dataset #5
         * @param s6Dataset input dataset #6
         * @param s7Dataset input dataset #7
         * @param s8Dataset input dataset #8
         * @param s9Dataset input dataset #9
         * @return output dataset
         */
        Dataset<D> apply(
                Dataset<S1> s1Dataset,
                Dataset<S2> s2Dataset,
                Dataset<S3> s3Dataset,
                Dataset<S4> s4Dataset,
                Dataset<S5> s5Dataset,
                Dataset<S6> s6Dataset,
                Dataset<S7> s7Dataset,
                Dataset<S8> s8Dataset,
                Dataset<S9> s9Dataset
        );

        /**
         * This utility method allows to chain a transformation on the output dataset. The transformation may maintain or change the output type.
         *
         * @param tx   transformation to apply on the output
         * @param <D2> type of the output after this transformation is applied
         * @return output dataset after the transformation
         */
        default <D2> Data9Transformation<S1, S2, S3, S4, S5, S6, S7, S8, S9, D2> andThen(DataTransformation<D, D2> tx) {
            return (s1, s2, s3, s4, s5, s6, s7, s8, s9) -> tx.apply(apply(s1, s2, s3, s4, s5, s6, s7, s8, s9));
        }

        /**
         * This utility method applies an encoder to the output dataset.
         *
         * @param encoder encoder to apply
         * @param <D2>    type of the output after this encoding is applied
         * @return output dataset after the encoding
         */
        default <D2> Data9Transformation<S1, S2, S3, S4, S5, S6, S7, S8, S9, D2> andThenEncode(Encoder<D2> encoder) {
            return andThen(Transformations.encode(encoder));
        }

    }

    /**
     * Applies a merge transformation to all the input DataPipes.
     *
     * @param pipe1  input DataPipe #1
     * @param pipe2  input DataPipe #2
     * @param pipe3  input DataPipe #3
     * @param pipe4  input DataPipe #4
     * @param pipe5  input DataPipe #5
     * @param pipe6  input DataPipe #6
     * @param pipe7  input DataPipe #7
     * @param pipe8  input DataPipe #8
     * @param pipe9  input DataPipe #9
     * @param merger transformation to apply
     * @param <S1>   type of the input DataPipe #1
     * @param <S2>   type of the input DataPipe #2
     * @param <S3>   type of the input DataPipe #3
     * @param <S4>   type of the input DataPipe #4
     * @param <S5>   type of the input DataPipe #5
     * @param <S6>   type of the input DataPipe #6
     * @param <S7>   type of the input DataPipe #7
     * @param <S8>   type of the input DataPipe #8
     * @param <S9>   type of the input DataPipe #9
     * @param <D>    type of the output DataPipe
     * @return outcome of the merge operation
     */
    public static <S1, S2, S3, S4, S5, S6, S7, S8, S9, D> DataPipe<D> mergeAll(
            DataPipe<S1> pipe1,
            DataPipe<S2> pipe2,
            DataPipe<S3> pipe3,
            DataPipe<S4> pipe4,
            DataPipe<S5> pipe5,
            DataPipe<S6> pipe6,
            DataPipe<S7> pipe7,
            DataPipe<S8> pipe8,
            DataPipe<S9> pipe9,
            Data9Transformation<S1, S2, S3, S4, S5, S6, S7, S8, S9, D> merger) {
        Dataset<D> mergedDataset = merger.apply(pipe1.dataset, pipe2.dataset, pipe3.dataset, pipe4.dataset, pipe5.dataset, pipe6.dataset, pipe7.dataset, pipe8.dataset, pipe9.dataset);
        return new DataPipe<>(mergedDataset);
    }

    /**
     * Data transformation interface that performs a custom-defined operation on 3 input Datasets
     *
     * @param <S1>  type of the input dataset #1
     * @param <S2>  type of the input dataset #2
     * @param <S3>  type of the input dataset #3
     * @param <S4>  type of the input dataset #4
     * @param <S5>  type of the input dataset #5
     * @param <S6>  type of the input dataset #6
     * @param <S7>  type of the input dataset #7
     * @param <S8>  type of the input dataset #8
     * @param <S9>  type of the input dataset #9
     * @param <S10> type of the input dataset #10
     * @param <D>   type of the output dataset
     */
    public interface Data10Transformation<S1, S2, S3, S4, S5, S6, S7, S8, S9, S10, D> {

        /**
         * Applies the transformation.
         *
         * @param s1Dataset  input dataset #1
         * @param s2Dataset  input dataset #2
         * @param s3Dataset  input dataset #3
         * @param s4Dataset  input dataset #4
         * @param s5Dataset  input dataset #5
         * @param s6Dataset  input dataset #6
         * @param s7Dataset  input dataset #7
         * @param s8Dataset  input dataset #8
         * @param s9Dataset  input dataset #9
         * @param s10Dataset input dataset #10
         * @return output dataset
         */
        Dataset<D> apply(
                Dataset<S1> s1Dataset,
                Dataset<S2> s2Dataset,
                Dataset<S3> s3Dataset,
                Dataset<S4> s4Dataset,
                Dataset<S5> s5Dataset,
                Dataset<S6> s6Dataset,
                Dataset<S7> s7Dataset,
                Dataset<S8> s8Dataset,
                Dataset<S9> s9Dataset,
                Dataset<S10> s10Dataset
        );

        /**
         * This utility method allows to chain a transformation on the output dataset. The transformation may maintain or change the output type.
         *
         * @param tx   transformation to apply on the output
         * @param <D2> type of the output after this transformation is applied
         * @return output dataset after the transformation
         */
        default <D2> Data10Transformation<S1, S2, S3, S4, S5, S6, S7, S8, S9, S10, D2> andThen(DataTransformation<D, D2> tx) {
            return (s1, s2, s3, s4, s5, s6, s7, s8, s9, s10) -> tx.apply(apply(s1, s2, s3, s4, s5, s6, s7, s8, s9, s10));
        }

        /**
         * This utility method applies an encoder to the output dataset.
         *
         * @param encoder encoder to apply
         * @param <D2>    type of the output after this encoding is applied
         * @return output dataset after the encoding
         */
        default <D2> Data10Transformation<S1, S2, S3, S4, S5, S6, S7, S8, S9, S10, D2> andThenEncode(Encoder<D2> encoder) {
            return andThen(Transformations.encode(encoder));
        }

    }

    /**
     * Applies a merge transformation to all the input DataPipes.
     *
     * @param pipe1  input DataPipe #1
     * @param pipe2  input DataPipe #2
     * @param pipe3  input DataPipe #3
     * @param pipe4  input DataPipe #4
     * @param pipe5  input DataPipe #5
     * @param pipe6  input DataPipe #6
     * @param pipe7  input DataPipe #7
     * @param pipe8  input DataPipe #8
     * @param pipe9  input DataPipe #9
     * @param pipe10 input DataPipe #10
     * @param merger transformation to apply
     * @param <S1>   type of the input DataPipe #1
     * @param <S2>   type of the input DataPipe #2
     * @param <S3>   type of the input DataPipe #3
     * @param <S4>   type of the input DataPipe #4
     * @param <S5>   type of the input DataPipe #5
     * @param <S6>   type of the input DataPipe #6
     * @param <S7>   type of the input DataPipe #7
     * @param <S8>   type of the input DataPipe #8
     * @param <S9>   type of the input DataPipe #9
     * @param <S10>  type of the input DataPipe #10
     * @param <D>    type of the output DataPipe
     * @return outcome of the merge operation
     */
    public static <S1, S2, S3, S4, S5, S6, S7, S8, S9, S10, D> DataPipe<D> mergeAll(
            DataPipe<S1> pipe1,
            DataPipe<S2> pipe2,
            DataPipe<S3> pipe3,
            DataPipe<S4> pipe4,
            DataPipe<S5> pipe5,
            DataPipe<S6> pipe6,
            DataPipe<S7> pipe7,
            DataPipe<S8> pipe8,
            DataPipe<S9> pipe9,
            DataPipe<S10> pipe10,
            Data10Transformation<S1, S2, S3, S4, S5, S6, S7, S8, S9, S10, D> merger) {
        Dataset<D> mergedDataset = merger.apply(pipe1.dataset, pipe2.dataset, pipe3.dataset, pipe4.dataset, pipe5.dataset, pipe6.dataset, pipe7.dataset, pipe8.dataset, pipe9.dataset, pipe10.dataset);
        return new DataPipe<>(mergedDataset);
    }

}
